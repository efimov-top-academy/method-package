1.	История Вычислительной Техники
2.	Введение в алгоритмы и программирование
2.1.	Основы алгоритмизации
2.1.1.	Алгоритмы.
2.1.2.	Составные команды: следования, ветвления, цикла
2.1.3.	Свойства и способы описания алгоритмов.
2.1.4.	Переменная. Операция присваивания.
2.1.5.	Вспомогательные алгоритмы. Подпрограммы. Процедуры и функции.
2.1.6.	Тестирование ПО

2.2.	Введение в языки программирования
2.2.1.	Языки программирования: определение, классификация.
2.2.2.	История языков программирования
2.2.3.	Классификации языков программирования
2.2.4.	Введение в C/C++

2.3.	Введение в разработку на C++
2.3.1.	Введение в компилятор, компоновщик и библиотеки
2.3.2.	Установка интегрированной среды разработки (IDE)
2.3.3.	Компиляция вашей первой программы
2.3.4.	Вывод информации на консоль.
2.3.5.	Несколько распространенных проблем C++

3.	Процедурное программирование. Язык С++
3.1.	Основы языка С++
3.1.1.	Инструкции (statement) и структура программы
3.1.2.	Комментарии
3.1.3.	Введение в объекты и переменные
3.1.4.	Переменные. Присваивание и инициализация.
3.1.5.	Введение в iostream: cout, cin и endl
3.1.6.	Форматированный ввод и вывод на языке C
3.1.7.	Неинициализированные переменные и неопределенное поведение
3.1.8.	Ключевые слова и идентификаторы именования
3.1.9.	Пробелы и базовое форматирование
3.1.10.	Введение в литералы и операторы
3.1.11.	Введение в выражения
3.1.12.	Разработка вашей первой программы

3.2.	Основные Типы Данных
3.2.1.	Введение в основные типы данных
3.2.2.	Преобразование между двоичной и десятичной системами счисления
3.2.3.	Подробно о различных системах счисления. Возможности и варианты использования.
3.2.4.	Представление числа в памяти
3.2.5.	Размеры объектов и оператор sizeof
3.2.6.	Целые числа со знаком
3.2.7.	Целые числа без знака
3.2.8.	Целые числа фиксированной ширины и size_the
3.2.9.	Числа с плавающей запятой
3.2.10.	Логические значения
3.2.11.	Введение в операторы if
3.2.12.	Символьный тип
3.2.13.	Невозвращаемый (неопределенный) тип void
3.2.14.	Введение в преобразование типов
3.2.15.	Константные переменные и символьные константы
3.2.16.	Неоптимизированные переменные (volatile)
3.2.17.	Литералы
3.2.18.	Системы счисления (десятичная, двоичная, шестнадцатеричная и восьмеричная)
3.2.19.	Теория по системам счисления

3.3.	Операторы
3.3.1.	Приоритет и ассоциативность операторов
3.3.2.	Арифметические операторы
3.3.3.	Деление по модулю (остаток от целочисленного деления)
3.3.4.	Операторы инкремента/декремента
3.3.5.	Операторы присваивания и модификации
3.3.6.	Оператор запятая
3.3.7.	Операторы сравнения (тонкости сравнения для чисел с плавающей запятой)
3.3.8.	Логические операторы
3.3.9.	Библиотека cmath
3.3.10.	Булева алгебра.
3.3.11.	Теория множеств

3.4.	Область видимости, продолжительность «жизни», связи переменных и объектов.
3.4.1.	Составные операторы (блоки фигурных скобочек)
3.4.2.	Локальные переменные. Локальная область видимости переменных.
3.4.3.	Затенение переменных (скрытие имен)
3.4.4.	Внутренняя связь
3.4.5.	Использование деклараций и использование директив (using)
3.4.6.	Определяемые пользователем пространства имен и оператор разрешения области

3.5.	Программный поток, управление потоком и обработка ошибок
3.5.1.	Введение в поток управления
3.5.2.	Операторы ветвления If, if-else, if-else if-else.
3.5.3.	Вложенное ветвление.
3.5.4.	Инструкция switch
3.5.5.	Введение в циклы и цикл с предусловием while
3.5.6.	Цикл с постусловием do while
3.5.7.	Цикл for. Восходящий, нисходящий, переменного шага.
3.5.8.	Команды break, continue, goto
3.5.9.	Вложенные циклы
3.5.10.	Остановки (halts — досрочный выход из программы)
3.5.11.	Введение в отладку и тестирование вашего кода
3.5.12.	Обнаружение и обработка ошибок
3.5.13.	assert и static_assert

3.6.	Подробно о преобразовании типов и значений
3.6.1.	Явное и неявное преобразование типов
3.6.2.	Преобразования с плавающей запятой и интегралом
3.6.3.	Числовые преобразования
3.6.4.	Арифметические преобразования
3.6.5.	Явное преобразование типов (приведение) и static_cast
3.6.6.	typedef и псевдонимы типов

3.7.	Функции. Основы.
3.7.1.	Введение в функции
3.7.2.	Функция, возвращающая значения (функции, возвращающие значения)
3.7.3.	Функции void (функции, не возвращающие значения)
3.7.4.	Введение в параметры или аргументы функции
3.7.5.	Введение в локальную область функций
3.7.6.	Глобальные переменные
3.7.7.	Статические переменные.
3.7.8.	Аргументы по умолчанию
3.7.9.	Прототип функции, сигнатура. Объявление и реализация.
3.7.10.	Структура процедурной программы. Использование функций в решении сложных задач.

3.8.	Введение в структуры данных.
3.8.1.	Общее понятие о структурах данных. Форма хранения и правила работы с ними.
3.8.2.	Одномерный массив константной длины.
3.8.3.	Введение в генерацию случайных чисел
3.8.4.	Алгоритмы генерации случайных чисел
3.8.5.	Базовые принципы работы с одномерными массивами.
3.8.6.	Массивы и циклы.
3.8.7.	Массивы и функции.
3.8.8.	Обработка массивов. Поиск экстремумов (минимального, максимального), отзеркаливание массива, сдвиг влево, вправо.
3.8.9.	Многомерные массивы константной длины.
3.8.10.	Обработка многомерных массивов.

3.9.	Введение в процесс отладки программы.
3.9.1.	Средства отладки в Visual Studio.
3.9.2.	Пошаговое исполнение. 
3.9.3.	Точки остановки
3.9.4.	Просмотр памяти.

3.10.	Битовые манипуляции.
3.10.1.	Преобразование между двоичной и десятичной системами счисления
3.10.2.	Представление чисел в памяти. Продвинутые сведения. Отрицательные числа. Вещественные числа.
3.10.3.	Арифметические операции над двоичными числами.
3.10.4.	Побитовые операции и операторы
3.10.5.	Битовые флаги и битовые манипуляции. std::bitset
3.10.6.	Битовые манипуляции с побитовыми операторами и битовыми масками

3.11.	Составные типы: Ссылки и Указатели
3.11.1.	Введение в составные типы данных. Категории значений (значения lvalues и rvalues)
3.11.2.	Ссылки на значения lvalue, ссылки на const
3.11.3.	Введение в указатели
3.11.4.	Нулевые указатели
3.11.5.	Указатели и константы
3.11.6.	Передача аргументов копированием, по указателю, по ссылке.
3.11.7.	Возврат значений по ссылке и возврат по адресу

3.12.	Введение в динамическое выделение памяти.
3.12.1.	Массивы и указатели. Индексы и адресная арифметика.
3.12.2.	Понятие приложение (сборка), запуск приложения, процесс.
3.12.3.	Поток, стек вызова функций, куча.
3.12.4.	Динамическое выделение и освобождение памяти в куче. new и delete
3.12.5.	Указатель типа void
3.12.6.	Динамическое выделение и освобождение памяти на языке С (alloc/malloc, free)
3.12.7.	Динамическое создание и удаление массива.
3.12.8.	Цикл foreach и автоматическое определение типа auto
3.12.9.	Указатель на указатель.
3.12.10.	Динамические многомерные массивы. Зубчатые массивы.

3.13.	Функции. Продвинутые возможности.
3.13.1.	Функции с переменным количеством аргументов.
3.13.2.	Рекурсивные функции.
3.13.3.	Рекуррентные соотношения. Числовые ряды.
3.13.4.	Введение в перегрузку функций
3.13.5.	Разрешение перегрузки функций и неоднозначных совпадений
3.13.6.	Шаблоны функций. Создание экземпляра шаблона функции
3.13.7.	Шаблоны функций с несколькими типами

3.14.	Структуры данных. Продвинутые возможности.
3.14.1.	Введение в поиск. Линейный поиск — реализация. Бинарный поиск.
3.14.2.	Простейшие алгоритмы сортировки: выбором, пузырьком, вставками.
3.14.3.	Реализация бинарного поиска.
3.14.4.	Продвинутые сортировки: шейкерная, расческой, Шелла.
3.14.5.	Быстрая сортировка.
3.14.6.	Сортировка слиянием.
3.14.7.	Пирамидальная сортировка.
3.14.8.	Введение в алгоритмическую сложность. O(N). Сложность по скорости и по памяти.
3.14.9.	Продвинутые сведения об алгоритмической сложности.

3.15.	C-style строки.
3.15.1.	Символы в С/С++
3.15.2.	Представление строки в оперативной памяти.
3.15.3.	Константные и динамические строки.
3.15.4.	Обработка строк. Базовые функции языка C/С++й
3.15.5.	Широкие символы и функции работы со строками широких символов.
3.15.6.	Библиотеки cctype, cstdlib, cstring

3.16.	Структуры данных. Пользовательские (составные) типы.
3.16.1.	Введение в программно-определяемые (определяемые пользователем) типы. Необходимость таких типов.
3.16.2.	Перечисления.  Обычные и классы перечислений.
3.16.3.	Введение в структуры, поля структур.
3.16.4.	Инициализация полей структуры
3.16.5.	Передача и возврат структур в функции.
3.16.6.	Указатели на структуры
3.16.7.	Шаблоны структур

3.17.	Файлы.
3.17.1.	Файлы как хранилище данных. Текстовые и бинарные файлы.
3.17.2.	Работа с файлами на базовых функциях языка С/С++.
3.17.3.	Текстовые файлы. Создание, запись, чтение.
3.17.4.	Бинарные файлы. Создание, запись, чтение.
3.17.5.	Текстовые файлы с широкими символами. Создание, запись, чтение.
3.17.6.	Файлы как сущность файловой системы.
3.17.7.	Базовые функции языка С/С++ для работы с файловой системой.

3.18.	Структуры данных. Продвинутые возможности. Связные списки.
3.18.1.	Введение в связные списки на основе структур.
3.18.2.	Однонаправленный список.
3.18.3.	Двунаправленный список.
3.18.4.	Кольцевые однонаправленный и двунаправленный списки.
3.18.5.	Организация порядка работы со структурами данных. Стек, Очередь. Дек.

3.19.	Функции. Продвинутые возможности.
3.19.1.	Указатель на функцию.
3.19.2.	Функции как аргументы для других функций (функции обратного вызова).
3.19.3.	Аргументы командной строки
3.19.4.	Шаблоны функций и auto
3.19.5.	Явная специализация шаблонной функции
3.19.6.	Анонимные (лямбда) функции. Лямбда-захваты

3.20.	Препроцессор и многофайловый проект С++
3.20.1.	Процесс сборки проекта.
3.20.2.	Директивы препроцессора.
3.20.3.	Заголовочный файл и файл реализации.
3.20.4.	Особенности работы с заголовочными файлами для шаблонных сущностей.
3.20.5.	Подробнее о пространствах имен. Неназванные и встроенные пространства имен
3.20.6.	Тонкие настройки компиляции в Visual Studio


4.	Введение в объектно-ориентированное программирование.
4.1.	Основы объектно-ориентированного программирования
4.1.1.	Классы и элементы класса: поля и методы. Состояние и поведение.
4.1.2.	Спецификаторы публичного и частного доступа
4.1.3.	Инкапсуляция. Методы аксессоры (геттер и сеттер)
4.1.4.	Конструкторы. Конструкторы по умолчанию и параметрические.
4.1.5.	Инициализация элементов класса.
4.1.6.	Инициализация нестатического элемента
4.1.7.	Перекрывающиеся и делегирующие конструкторы
4.1.8.	Деструкторы. 
4.1.9.	Классы, объекты и скрытый указатель this
4.1.10.	Анонимные объекты. Методы, возвращающие объект класса. Цепочки методов.
4.1.11.	Классы, константные поля и константные методы.
4.1.12.	Статические поля класса.
4.1.13.	Статические методы класса.
4.1.14.	Дружественные функции и классы.
4.1.15.	Вложенные пользовательские типы в классах
4.1.16.	Классы, файлы заголовков и файлы реализации.
4.1.17.	Тонкий момент заголовочных файлов для шаблонных классов.

4.2.	Отладка программного кода.
4.2.1.	Внутренний отладчик Visual Studio
4.2.2.	Просмотр памяти, стека вызова функций, значений и адресов переменных, значений контрольных значений.
4.2.3.	Измерение времени выполнения кода.
4.2.4.	Дополнительные возможности. Потоки, регистры и пр.

4.3.	ООП. Перегрузка операторов
4.3.1.	Введение в перегрузку оператора.
4.3.2.	Три варианта перегрузки операторов. Технологии перегрузки для бинарных у унарных операторов.
4.3.3.	Перегрузка арифметических операторов с использованием дружественных функций
4.3.4.	Перегрузка операторов с использованием сторонних функций
4.3.5.	Перегрузка операторов ввода-вывода
4.3.6.	Перегрузка операторов с использованием функций-членов
4.3.7.	Перегрузка унарных операторов
4.3.8.	Перегрузка операторов сравнения
4.3.9.	Перегрузка операторов инкремента и декремента
4.3.10.	Перегрузка оператора индекса. Индексаторы.
4.3.11.	Перегрузка оператора круглых скобок. Функторы.
4.3.12.	Функторы возвращающие логическое значение. Предикаты.
4.3.13.	Функторы — алгоритмы.
4.3.14.	Перегрузка приведения типов
4.3.15.	Конструктор копирования. Константные аргументы по ссылке.
4.3.16.	Инициализация поверхностным копированием.
4.3.17.	Конструкторы преобразования. explicit, implecit
4.3.18.	Перегрузка оператора присваивания
4.3.19.	Поверхностное и глубокое копирование
4.3.20.	Использование классов с перегруженными операторами. Примеры.

4.4.	Введение в связи между классами и объектами.
4.4.1.	Объектные отношения («является частью», «содержит», «зависит», «использует» и пр)
4.4.2.	Композиция объектов. Сильная связь части и целого.
4.4.3.	Агрегация объектов. Слабая связь части и целого.
4.4.4.	Ассоциация. Слабая связь двух частей.
4.4.5.	Зависимости. Поверхностная связь двух частей.

4.5.	Введение в контейнеры.
4.5.1.	Классы контейнеров
4.5.2.	std::initializer_list
4.5.3.	Собственные классы динамического массива, строки, связного списка и бинарного дерева.

4.6.	Наследование
4.6.1.	Введение в наследование
4.6.2.	Базовое наследование в C++. Самая сильная связь между классами и объектами.
4.6.3.	Порядок построения производных классов
4.6.4.	Конструкторы и инициализация производных классов
4.6.5.	Спецификаторы наследования и доступа. Защищенные элементы класса.
4.6.6.	Добавление новой функциональности в производный класс
4.6.7.	Вызов унаследованных функций и переопределение поведения
4.6.8.	Скрытие унаследованной функциональности
4.6.9.	Множественное наследование

4.7.	Полиморфизм. Виртуальные методы
4.7.1.	Указатели и ссылки на базовый класс производных объектов
4.7.2.	Виртуальные функции и полиморфизм
4.7.3.	Спецификаторы override и final, а также ковариантность возвращаемых типов
4.7.4.	Виртуальные деструкторы, виртуальное назначение и переопределение виртуализации
4.7.5.	Раннее и позднее связывание
4.7.6.	Таблица виртуальных методов
4.7.7.	Чисто виртуальные функции, абстрактные базовые классы и интерфейсные классы
4.7.8.	Виртуальные базовые классы
4.7.9.	Обрезка объектов при присваивании, передачи в функцию.
4.7.10.	Динамическое приведение типов. dynamic_cast
4.7.11.	Проблема наследственной перегрузки оператора вывода <<. Решение.

4.8.	ООП. Шаблоные классы
4.8.1.	Шаблоны в применении к классам
4.8.2.	Параметры non-type.
4.8.3.	Явная специализация шаблона класса
4.8.4.	Частичная специализация шаблонов
4.8.5.	Частичная специализация шаблона для указателей

4.9.	Семантики копирования и перемещения. Умные указатели
4.9.1.	Введение в умные указатели и семантику перемещения
4.9.2.	Ссылки на l-value. Ссылки на r-value.
4.9.3.	Конструкторы перемещения и принцип перемещения
4.9.4.	std::move и std::move_if_noexcept
4.9.5.	std::unique_ptr, std::shared_ptr, std::weak_ptr
4.9.6.	Создание итераторов для классов собственных контейнеров.

4.10.	Исключения.
4.10.1.	Смысл и необходимость исключений
4.10.2.	Базовая обработка исключений
4.10.3.	Исключения, функции и разматывание стека
4.10.4.	Неперехваченые исключения и обработчики catch_all
4.10.5.	Исключения stl, классы и наследование
4.10.6.	Выбрасывание исключений throw
4.10.7.	try блоки
4.10.8.	Опасности и недостатки исключений 
4.10.9.	Спецификации исключений и noexcept

4.11.	STL. Строковой тип.
4.11.1.	string, string_view

4.12.	STL. Файловый ввод и вывод

4.13.	STL. Базовые функции, структуры и классы
4.13.1.	Трехстороннее сравнение
4.13.2.	Утилиты общего назначения (обмен, присваивание, вывод)
4.13.3.	Пары и кортежи.

4.14.	STL. Контейнеры.
4.14.1.	Последовательные контейнеры
4.14.2.	array, vector, deque, forward_list, list
4.14.3.	Ассоциативные контейнеры
4.14.4.	set, map, multiset, multimap
4.14.5.	Несортированные ассоциативные контейнеры
4.14.6.	unordered_set, unordered_map, unordered_multiset, unordered_multimap
4.14.7.	Контейнерные адаптеры
4.14.8.	stack, queue, priority_queue
4.14.9.	Концепция и реализация итераторов в контейнерах.

4.15.	STL. Библиотека алгоритмов.
4.15.1.	Немодифицирующие алгоритмы.
4.15.2.	for_each, find, count и пр.
4.15.3.	Модифицирующие алгоритмы.
4.15.4.	copy, fill, generate, reverse и пр.
4.15.5.	Алгоритмы разделений
4.15.6.	partition и пр.
4.15.7.	Сортирующие алгоритмы и бинарного поиска
4.15.8.	Прочие алгоритмы.

4.16.	STL. Библиотеки
4.16.1.	Библиотека форматирования.
4.16.2.	Библиотека работы с датой и временем
4.16.3.	Библиотека диапазонов
4.16.4.	Библиотека файловой системы
4.16.5.	Библиотека регулярных выражений.
4.16.6.	Регулярные выражения. Подробно.

4.17.	STL. Параллельное программирование
4.17.1.	Потоки. Многопоточность. 
4.17.2.	Синхронизация между потоками.
4.17.3.	Асинхронные задачи и взаимодействие между ними.

4.18.	C++. Сборки, библиотеки, модули
4.18.1.	Понятие сборки. Структура исполняемого файла.
4.18.2.	Статические и динамические библиотеки.
4.18.3.	Модули (C++20)

4.19.	WinAPI и C++
4.19.1.	Типы данных в Win32 API
4.19.2.	Создание оконной процедуры в Win32 API
4.19.3.	Ввод и вывод данных Win32 API

