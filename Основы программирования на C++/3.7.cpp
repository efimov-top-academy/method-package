//Тема функций

Глава 3.7 - Функции

Функции это весьма интересная и обширная тема.Функции решат массу проблем, в первую очередь связанных с удобством работы кода и заканчивая банальной оптимизацией процессов, которые происходят внутри ваших программ.
Но, если начинать пытаться объяснить - Что такое функция ? И зачем она нужна ? - определенно, в начале, стоит накинуть несколько проблем, которые привели к появлению функций.

Часть 1 - Не бывает слишком много кода... или бывает ?

Итак, представим следующую ситуацию - Вы создаете программу, которая вычисляет периметр и площадь прямоугольника.Для тех, кто забыл школьную программу, напомню, что периметр прямоугольника равен удвоенной сумме его длины и ширины, а площадь произведению тех же длины и ширины.В поставленной задаче все кажется простым - принимаем два числа(ширина и длина прямоугольника) от пользователя и вычисляем по ним необходимые параметры.НО пришел заказчик и сказал - Хочу, чтобы программа еще и объем параллелепипеда с этим прямоугольником в основании!Вы, как программист, отвечаете, что нет проблем, запрашиваете у пользователя высоту и умножаете ее на площадь прямоугольника.Все, можно в релиз ?
Нет, нельзя.Почему ? Потому что заказчик снова пришел и потребовал, что бы у нас был выбор какую фигуру мы сейчас хотим вычислить.Вы скрепя зубами, вносите новые правки, ставя switch и надеясь, что больше правок то не будет.Но через месяц заказчик приходит и накидывает еще требования на 3 фигуры в разных измерениях.
И вот так, постепенно, ваша программа превращается в длинную простыню кода, которую нужно после вас еще кому - то поддерживать.Легко ли это будет ? Естественно нет, вы сами то через месяц забудете половину функционала, а через год каждая ошибка в коде будет отзываться болью в голове.Это и есть проблема номер 1 - без использования функций, получается длинный, плохо читаемый и самое главное непрерывный код, поддержка которого сложна сама по себе из - за проблем поиска ошибок и попыток понимания, что к ним привело.
Проще говоря, ваш код выглядит как одна большая простыня и понять что и где в ней крайне сложно.Это мы еще о переменных не вспоминали - с ними в этом случае твориться отдельный ад.
НО давайте вернемся к первоначальным правкам нашего неуемного заказчика.Напомню, что он захотел, чтобы ваша программа вычисляла нужные параметры как для прямоугольника, так и для параллелепипеда.Однако, чем по сути отличается площади основания параллелепипеда и площадь прямоугольника ? Ответ - ничем.Это одно и то же измерение, которое выполняется по одной и той же формуле.Но сейчас, в вашей программе, придется фактически сделать два одинаковых участка кода - первый вычисляет площадь прямоугольника, а второй площадь основания параллелограмма.И это как раз проблема номер 2 - без использования функций в вашем коде начнется множественное повторение участков, которые по сути своей будут выполнять одни и те же действия.
Проще говоря, вы будете повторять один и тот же код несколько раз, вместо того, что бы использовать уже ранее наработанный.

Оговорка - тут стоит сказать, что рассмотренная задача крайне простой случай, специально придуманный для наглядности.В реальной кодовой базе проблема повторного использования кода может быть далеко не столь явной и попросту скрываться за сложной логикой приложения.А если говорить о микро сервисной архитектуре, так вообще невозможно будет до нее докопаться.Поэтому не стоит относиться к этому с пофигизмом - повторюсь, мы специально упростили задачу.

Итак, мы имеем две большие проблемы :
1 - Наш код выглядит, как одно полотно, которое руки так и чешутся разбить на блоки, для более простого понимания
2 - Помимо этого в нашем коде еще и множество повторений, которые делают одно и тоже и очень просятся под нож.

Часть 2 - Двух зайцев одним выстрелом

Собственно эти две проблемы и решают функции в первую очередь. Они разбивают код на отдельные блоки, каждый из которых позже вы сможете протестировать и разобрать на липовый цвет и мед, в смысле на ошибки и исключения, а так же позволяет вызывать эти самые блоки в любом месте кода необходимое количество раз, без повторения самого куска кода.Из всего вышеописанного вытекает ответ на вопрос - Зачем нужна функция ? А вот теперь мы дадим определение, которое ответит на вопрос - Что такое функция ?

Определение - Функция - это именованная область кода, которая принимает в себя некоторые значения(параметры или аргументы) и возвращает(или не возвращает) некоторый ответ после своих действий.

Ничего не понятно ? Мозг подвис ? Все нормально, сейчас разберемся.
Начнем буквально по словам.В первую очередь функция - это именованная область кода.Что это значит ? Все довольно просто - у функций есть имя, по которому их можно вызвать, и собственный код, который они выполняют.Первая функция, которую вы все уже писали и переписывали множество(мы надеемся, что множество) раз - это функция main.Ее имя собственно main, а область кода, за которую она отвечает, это тот самый код, который вы писали в своих программах ранее.Теперь чуть подробнее.

Имя функции подчиняется общим правилам именования всего в языке С++.Так как мы их рассматривали ранее, здесь не будем повторяться полностью, а лишь приведем краткий список :
1) Имя не может начинаться с цифры, хотя может их содержать
2) Имя не может состоять из пробелов или содержать специальные символы, кроме _
3) Имя не может использовать ключевые слова Языка Программирования C++
4) Имя не может состоять или содержать русские(кириллические) символы.
Так же, ранее, для переменных вам говорили, что имена не могут повторяться и в функциях, в целом, это правило сохраняется.Однако есть такое явление, как перегрузка функций, о котором пойдет речь позже, где используются одинаковые имена у разных функций.Поэтому давайте договоримся так формулировать - Имена у РАЗНЫХ по функционалу функций обязаны быть разными(тавтология наше все).

Еще к функциям есть несколько дополнительных требований :
1) Если функция отвечает на какой - то вопрос, например строка ли то что ей передали - ее имя должно начинаться с приставки is - isString, isMain, isVasa
2) Если функция выполняет преобразование из одного типа в другой, то ее имя принято начинать с приставки from - fromString, fromBool, fromCat(злой хохот)
и так далее.
Но эти правила являются скорей удобством, чем жестким требованием самого языка и учатся в ходе практики, так как без серьезной задачи вы вряд - ли набьете руку в именах.В конце главы будут приведены несколько приставок, наиболее распространенных среди программистов.Постарайтесь их запомнить и использовать.

Область кода же, практически, ничем не ограничена, кроме вашей фантазии и фигурных скобок - {}. Функции бывают как однострочными, так и больше даже основной программы.Но тут нам хотелось бы уточнить вот какой момент / правило - одна ноша в одни руки.То есть каждая функция должна выполнять только ТО, что от нее ожидается и это далеко не так очевидно, как может показаться.
Например, возвращаясь к нашей задаче о прямоугольнике, должна быть функция, которая считает его площадь.НО - она только считает площадь и возвращает ее значение, не выводя ее в консоль!Сейчас вам будет казаться, что это лишняя трата времени и почему бы просто не вывести там где удобнее, но это один из тех моментов, когда нужно принять как есть, а понять потом.Загвоздка здесь именно в том, что от вызова функции ожидают, что она просто посчитает необходимое значение, а не станет еще куда - то его выбрасывать дополнительно.Так обеспечивается предсказуемость поведения кода, а это очень важный аспект, когда вы работаете над большим проектов, да еще и в команде. Поэтому запомните и возьмите за правило - Функция ОБЯЗАНА выполнять только те действия, которые от нее ожидают.

Часть 3 - Как создать функцию?

Теперь давайте, наконец, опишем шаблон для создания функций и далее уже полностью его разберем:

Шаблон: 
	Возвращаемый_тип Имя_Функции(параметры_функции)
	{
		тело_функции
	}

Как можно заметить, если откинуть тело функции и ее параметры, вы увидите обычную переменную и это далеко не просто так. Сейчас мы не будем углубляться в эту тему, но ниже вы еще вспомните об этом сравнении и научитесь даже создавать переменные, в которых лежат функции. Сейчас же давайте рассмотрим, что находится в шаблоне:
	1) Возвращаемый_тип - это тип данных, который возвращает функция туда, где была вызвана. Например, если функция должна сложить два целых числа и вернуть их сумму, то ее возвращаемый тип будет int. 
	2) Имя_Функции - это, как и говорилось ранее, имя, по которому вы будете обращаться к функции и вызывать ее для исполнения ее работы. 
	3) Параметры_функции - это то, что необходимо передать функции для ее работы. Например, если функция должна взять два числа для их сложения, то в параметрах указывается две переменных, в которые будут записаны эти значения и внутри функции можно будет использовать именно эти переменные.
	4) Тело_функции - это, как и говорилось ранее, код, который будет исполняться при вызове функции. Важно отметить, что для читаемости кода необходимо оставлять фигурные скобки на отдельных строчках, как это показано в шаблоне. Самому коду не будет никакой разницы, а вот ваши будущие коллеги будут благодарны вам за подобное оформление кода.

Как видите, в описании функции нет ничего сложного, немного практики и вы быстро привыкните их создавать, описывать и использовать в своем коде. А теперь давайте разберем новые понятия поподробнее. 

Часть 4 - Ты мне два яблока, я тебе одно... 

	Возвращаемый тип данных функции это весьма не простая вещь, как это может показаться на первый взгляд. Функция буквально может возвращать любой из известных вам типов во всех их вариациях. Важно только понимать, что же вы возвращаете и собственно выполнить это возвращаение. Но для начала ответим на вопрос вообще зачем нужен возвращаемый тип? 

	А необходимо он для того, что бы она сама фукнция могла понимать, что вы хотите получить после ее работы, а так же это даст возможность использовать результат функции в качестве значения для переменных или напрямую в каких то местах, вместо самих переменных. Не волнуйтесь, мы не оставим этот момент без внимания и позже, на примерах, покажем о чем вообще идет речь.

	Для того, что бы вернуть то, что нам необходимо из функции, нужно использовать ключевое слово return в теле функции. 
	Например:

	int Sum ()
	{
		int Seven = 5 + 2;
		return Seven;
	}

	В нашем примере мы создали функцию Sum, которая вернет нам сумму чисел 5 и 2, то есть 7, значение которых записано в одноименной переменной. По правде говоря, можно было обойтись вовсе без переменной и записать просто return 5 + 2;, но так работают с return редко, поэтому основной пример все таки создает переменную. 

	ВАЖНО - Если вы можете обойтись без лишних переменных, лучше обходится без них. Это сэкономит память и уменьшит время работы функции до минимума. Помните - оптимизация наше все!

	В целом, вы должны возвращать тот тип данных, который указали при описании функции, но есть одно НО. Вы уже знаете о том, что такое преобразование типов данных и с функциями и их возвращаемыми значениями это тоже работает. Проще говоря, если C++ может преобразовать данные к возвращаемому типу, вы не получите ошибку при сборке программы и она полноценно выполнится. В ином случае вы столкнетесь с ошибкой неверного типа данных. Важно понимать, что преобразование типов данных в возвращаемом значении - это всегда плохо. Просто весь вопрос в том - понимаете ли вы зачем вам это надо, а не допускаете ошибку просто потому что незаметили. В этом вопросе мы рекомендуем следовать правилу "Что заказали - то мы и отдали", то есть какой тип данных указан в возвращаемом для функции, информацию такого типа данных и возвращайте.

	Отдельно стоит упомянуть новый тип возвращаемого значения - void. Буквально с английского слово void переводится как пустота и это максимально хорошо описывает зачем нужен этот тип данных. Он необходим, дабы функция ничего не возвращала. Сейчас вам будет казаться, что он вовсе не нужен, так как функция должна всегда что-то возвращать, но поверьте - в программировании большая часть функций создаются именно void, потому что они просто делат свою работу и не более. (тут можно вставить картинку "это не много, но это честный труд" или "я сделяль")

	Кстати, даже если функция ничего не возвращает в ней все равно нужно указывать слово return, только вот Visual Studio об этом уже вам не напомнит. Вообще нужно о return отдельно поговорить, так как это важное ключевое слово и мы это обязательно сделаем, но позже.

Часть 5 - Я буду биться за двоих, нет за пятерых... за десятерых

	Параметры функции - это, фактически, значения, которые мы передаем внутрь функции, что бы она могла выполнить свои действия так, как нам необходимо. 
	Параметры фукнции могут быть самых разнообразных типов, а их количество огрничено лишь вашими желаниями. Однако, важно знать, что если вы указали параметр при создании функции, то при каждом ее вызове вы обязаны будете передавать этот параметр. То есть, если вы от всей широты своей души, указали 10 параметров, то будьте добры их каждый раз и передавать. Именно поэтому к списку параметров тоже нужно подходить с умом и указывать только те, которые реально необходимы функции для ее работы. 
	Возвращаясь к нашему примеру с функцией Sum, давайте укажем парочку параметров для ее работы:
	int Sum (int First, int Second)
	{
		return First + Second;
	}
	
	Здесь мы указали два параметра, тип int, которые будут записывать в себя те значения, которые мы захотим сложить с помощью функции Sum. Как видите, создание параметром абсолютно похоже на создание переменных в обычной программе. 
	Так же вы могли заметить, что все параметры указываются поочереди, через запятую. Предвосхищая вопрос, нет, указывать сразу нескольким параметрам один тип, как вы это делали в переменых, нельзя. Это как раз то, что отличает параметры функции от переменнных. Поверьте, вы привыкните! ("вставить мем Ты привыкнешь")
	Сделана эта механика для того, что бы не усложнять задачу компилятору, которому есть чем еще заниматься при сборке кода, помимо наших желаний упростить себе задачу. 

	Не менее важно будет отметить, что параметры отображаются IDE программисту, когда он начинает описывать вызов функции. Поэтому так важно во-первых дать максимально осмысленное название каждому параметру, а во вторых указать, что вы будете с ним делать. Здесь имеется ввиду, собираетесь ли вы его менять или критично ли он нужен при вызове и так далее...
	
	Первое, что стоит запомнить - если вы не хотите менять параметр, укажите его с ключевым словом const. На показанном ранее примере:

	int Sum (const int First,const int Second)
	{
		return First + Second;
	}

	Это нужно делать для того, что бы сказать программисту, который будет использовать вашу функцию, что данный параметр не меняется в ходе работы функции. Пока вы работаете один, это может казаться лишней тратой времени, но станет очень важным моментом, когда начнется работа в команде. Потому мы бы советовали привыкнуть к такому стилю.
	Так же const параметры могут принимать значение напрямую при вызове. Имеется ввиду, что если вы захотите передать в функцию не переменную, а просто число или строку - то параметр обязан быть const, потому что только такой параметр сможет принять это значение.

	Второе - параметры могут быть необязательными для функции. Так, стоп! Немного выше мы говорили, что сколько указали параметров, столько и передали, а теперь они могут быть необязательнымы?!
	И да, и нет. В языке программирования С++ имеется такое понятие, как инициализация по-умолчанию. Оно означает, что если в переменную ничего не передают, то у нее все равно будет некоторое значение, которе укажет программист. Сделано это для уменьшения ошибок при работе программы - пользователь ленив, пользователь может задать не все из необходимых параметров. 
	Тоже касается и функций - вы можете задать значения по-умолчанию параметрам, которые не критичны для ее выполнения. Допустим, что в нашей функции суммирования предусмотрена возможность не указывать второй параметр, то есть число которое мы будем прибавлять к первому. Вместого этого параметра должна вставать 1, а функция просто будет увеличивать значение на 1. Тогда код будет выглядеть следующим образом:

	int Sum (const int First,const int Second = 1)
	{
		return First + Second;
	}

	Ничего сложного. Теперь, если нам не передадут значение Second, то оно автоматически будет задано как 1. И овцы сыты, и волки целы, в смысле - и пользователь доволен, и программа стабильна. Однако есть два момента:

	Момент первый - ВСЕ параметры со значениями по-умолчанию всегда указываются в конце. Это необходимо, что бы компилятор, собирая код, не запутался. Поэтому запоминаем - сначала идут обычные параметры и только после них параметры со значениями. 

	Момент второй - значения по умолчанию необходимо указывать только тем параметрам, которые с точки зрения функции могут быть не столь критичны. То есть, если вы делаете функцию вывода на экран, то можете указать bool флаг о том, нужно ли переносить на следующую строчку после вывода или нет, но вы не можете указать значение по-умолчанию для самой информации, которую нужно вывести, потому что в этом случае функция потеряет свой смысл. С опытом вы поймете какие параметры стоит указывать со значениями по-умолчанию, а какие нет.

	Резюмируя - параметры функции важная вещь, которая позволяет дать необходимую информацию функции для ее работы, а так же сказать программисту, который вызывает функцию, чего ему ожидать от нее. Их может быть сколько угодно и некоторые из них могут сами задавать себе значения, если им их не предоставили. 

Часть 6 - Внутри меня водится, ну что ж с таким водиться...

	О теле функции мы уже рассказывали более подробно выше, однако здесь нужно упомянуть несколько очень важных аспектов. 

	Во-первых - как говорилось ранее, КАЖДАЯ функция обязана иметь в своем теле ключевое слово return или даже несколько. Пришло время о нем поговорить.
	Ключевое слово return является не только командой, которая вернет некоторое значение из функции, но так же и точкой окончания функции. То есть - весь код, который вы напишете после слова return, будет проигнорирован и не будет исполнятся. Из этого же правила следует то, что писать несколько return друг за другом не имеет смысла. 
	Но ведь буквально пару строк назад мы написали, что return может быть несколько?! Да, но это нужно показать на примере. 

	bool isTrue(const bool flag)
	{
		if (flag)
			return true;
		else
			return false;
	}

	Максимально бесполезная, конечно, функция, но она хорошо показывает как используются несколько return. В зависимости от того, какой нам передадут flag мы выбираем, что вернуть. То есть можно вывести правило - функции, в которых используются операторы ветвления, обязаны иметь return в каждом ветке, дабы любая из возможных ситуаций приводила к возвращению необходимого значения.
	
	Интересный факт - очень часто return используют в функциях с циклами вместо break - то есть когда цикл найдет нужный параметр или досчитает до нужного результата из функции можно выйти сразу через return, вместо того, что бы в ручную завершать цикл, записывать значение и передавать его на вывод. 

	Во-вторых - внутри функций вы можете осуществлять вызов других функций и так очень очень много раз. Почему не до бесконечности? Потому что ограничение этому есть и связано оно с размером такой вещи, как стек вызовов. С ним вы познакомитесь позже, пока запомните, что у вас примерно 4000 таких вызовов из одной в другую. 

	ВАЖНО - вы НЕ можете вызывать повторно функцию main в любой другой функции! Это и нарушает все требования по оформлению кода и в целом не имеет никакого смысла.

	В-третьих - вы можете внутри функции создавать переменные, но существовать они будут только внутри этой функции. Как только вы выйдете за пределы тела функции - все переменные будут автоматически удалены.

	В остальном тело функции является таким же алгоритмом, как и любая другая часть программы - он начинается сверху и выполняется вниз до ключевого слова return.

Часть 7 - Вы меня звали?

	Итак, теперь вы знаете все неободимое о функциях и осталось лишь упомянуть маленькую деталь - а как их собственно вызывать? То есть вот мы описали функцию, все в ней учли, все подготовили, как нам ее собствено использовать? 
	На самом деле все крайне просто - для вызова функции нужно всего лишь указать ее имя и параметры:

	Шаблон - Имя_Функции(Передаваемые_значения)

	Соответственно Имя_Функции обязано быть полностью идентично тому, что вы указали при ее создании, а Передаваемые_значения обязаны отвечать требованиям функции, то есть вы должны передать все те параметры, которые нужны функции.

	Пример:

	bool isTrue(const bool flag)
	{
		if (flag)
			return true;
		else
			return false;
	}

	int main()
	{
		isTrue(true);
	}

	Здесь мы собствено вызвали нами написанную функцию в функции main. Как видите, ничего сложного. Только нужно Сказать о двух моментах:
	Первый - вы обязаны объявить функцию ДО того как ее вызывать. Кажется очевидным, но тут сложность вот в чем - просто наличие функции в файле с кодом не говорит о том, что вы можете ее вызывать в любом его месте. Для вызова ее в функции main необходимо описать функцию ДО функции main

	Второй - в нашем примере мы передали значение параметра flag сразу в вызове, но на месте true спокойно могла быть любая переменная. Однако, как и говорилось ранее, так как мы сейчас показали можно передавать только те параметры, что обозначены const. В ином случае вы должны будете передать именно переменную.

	Вот теперь вы точно готовы к погружению в мир своих функций! 