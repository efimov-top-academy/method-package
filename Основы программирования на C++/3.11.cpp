//Составные типы: Ссылки и Указатели

Тема 3.11 - Составные типы : Ссылки и Указатели

Ох, ну что можно сказать - Добро пожаловать в Ад! Нет, серьезно - сегодня вы приступаете к самой сложной теме всего программирования на C++ и узнаете об одной из сложнейших вещей в мире программирования в целом, а именно о работе с памятью.

Чем эта тема сложна? Тем, что она очень перегружена разными hardware терминами и принципами, а так же полностью абстрактна, но мы постараемся рассказать ее максимально просто, что бы вы поняли и могли использовать в своих программах все механизмы работы с памятью!

Но, перед началом, стоит упомянуть - почему это так важно? И ответ одновременно очень простой и очень сложный - потому что ваша программа, неважно что она делает, должна делать это - Быстро, Дешево и Качественно. Быстро - то есть за минимальное количество тактов процессора, Дешево - то есть используя минимум памяти устройства, Качественно - то есть без ошибочно. И вот как раз для Дешевизны и нужно понимать то, как устроена сама память программы и как в целом используется память компьютера внутри ваших и других программ. Но обо всем по порядку.

Начнем, как это водится, с проблемы.

Часть 1 - Маленькая проблема, породившая целый мир!

На самом деле первая проблема, а в данной главе их будет несколько, максимально простая и демонстрируется буквально парой строк кода:

void fun(int count)
{
    ++count;
    return;
} 

void main()
{
    int First = 0;
    fun(First);
    cout << First << endl;
    return;
}

Что выведет данный код? Единицу или Ноль? Правильный ответ - Ноль. Проверьте сами - сколько функцию fun не вызывай, выводить все равно будет только 0. Почему?

Хорошо, вы можете сейчас легко ответить, что нужно было создать функцию с возвращаемым int значением и присваивать ее возврат в First. Сказано - сделано.

int fun(int count, int SecCount)
{
    ++count;
    ++SecCount;
    return count;
} 

void main()
{
    int First = 0, Second = 2;
    First = fun(First, Second);
    cout << First << Second << endl;
    return;
}

Теперь все отлично - First получает свою единичку и все довольны! Но вот незадача, у нас появился второй параметр и его тоже нужно вернуть из функции, а как это сделать, одновременно с первым? Не ломайте голову - никак. В C++ функция может возвращать только одно значение. И вот мы снова с той же проблемой - как вернуть значение из функции, если это сделать не возможно?

Именно такая проблема и порадила всю работу с памятью в C и C++ и, что забавно, решение ей очень элегантно и очень не типично - Нам не потребуется возвращать значение из функции, если функция сама будет работать с нашим исходным значением! Перефразируя - нам не придется возвращать значение в переменную, если мы дадим функции саму переменную. 

Ничего не поняли? Заинтригованы? Тогда поехали!

Часть 2 - Передаем коробку или Что такое ссылка?

Как говорилось в самом начале этого курса - переменная, это именованная область памяти. То есть, создавая переменную, вы попросили у операционной системы дать вам кусочек памяти, в который поместится эта переменная и, когда вам этот кусочек дали, вы, на радостях, дали ему имя, что бы потом использовать в своей программе. 

НО - для операционной системы, компилятора и в целом для компьютера - эта область памяти все еще остается областью памяти. Им на самом деле все равно, как вы обращаетесь с ней, как называете и что в ней храните (вернее, какое именно значение, а не буквально все что угодно). Они лишь знают, что если вы просите дать переменную First - вам нужен доступ к области памяти, в которой лежит эта переменная First.

Как мы уже видели выше, просто использовать имена переменных не выходит - в программе появляются разные локальные области кода, функции, а потом появятся классы и их объекты. И во всех этих вещах переменные существуют отдельно друг от друга, но хуже того, могут еще и повторяться (именами имеем ввиду). 

Поэтому в какой то момент и задумались - а зачем нам использовать имя? Почему бы не использовать сам адрес памяти? Если мы передадим его, то функция поймет, что мы хотим записать именно в нужную нам ячейку памяти и возвращать что-то из нее уже не потребуется. Проще говоря - функция просто поменяет значение сразу там где нужно, а в основной программе больше не потребуется выполнять никаких операций.

Собственно, как вы могли догадаться, ссылки и указатели занимаются тем, что бы хранить эти самые адреса памяти. Разница между ними состоит в том, что у ссылки поменять адрес мы не можем, а у указателя можем, но об этом позже. Сейчас к коду:

void main()
{
    int First = 0;
    int &Second = First;
}

В приведенном примере мы создали переменную First и присвоили ей значение 0, а после создали еще одну переменную Second в которую поместили значение First.Вроде все как и раньше, за исключением амперсанда (&) - как раз этот специальный символ и означает в языке программирования C++ ссылку. 

То есть в Second у нас лежит не цифра 0, а буквально адрес переменной First. Как в этом можно убедиться? Очень просто:

void main()
{
    int First = 0;
    int &Second = First;

    ++Second;

    cout << First << endl;
}

Мы вроде бы поменяли значение Second и совсем не трогали First, но на экране вы увидите 1, а не 0. Почему так? Потому что, когда вы поменяли значение того, что лежит внутри Second, компилятор увидел, что это ссылка и перешел по ней в ту память, на какую она указывала и поменял значение уже в ней. И так каждый раз - сколько бы вы не меняли Second, все тоже самое отразиться и на First. Верно и обратное утверждение - сколько бы вы не менял First, аналогично поменяется и Second. Из этого мы делаем вывод, что First и Second жестко связаны между собой и даже больше - разорвать эту связь невозможно (пока что).

Теперь давайте к определению:

Ссылки - это особый вид переменных, которые хранят не конкретное значение, а адрес другой переменной в памяти из-за чего любые изменения с ссылкой отражаются на той переменной, на которую она ссылается. Верно и обратное утверждение!

Если пытаться привести пример из жизни, то самым наглядным, нам кажется, будет сравнение переменных с коробками на складе, а ссылок с записями в журнале у вахтера этого склада. 

Например, вы храните на складе ящик с бутылочками Coca Cola. Сколько их там? В каком они состоянии? Можно ли взять или положить в ящик еще бутылочек? - вахтер не знает. Да и не должен, по хорошему. А вот где найти этот ящик - он знать обязан! И собственно адрес этого ящика на складе - номер ангара, стеллаж, полка и позиция на полке - у него и записаны в его журнале. Если что то нужно сделать конкретно с этим ящиком Coca Cola - вахтер сможет вас к нему отвезти! 

Интересный факт: 
    Забавно, но получилась аллюзия на Сокрытие в Объектно-Ориентрованном Программировании. Честно, не было цели ее делать, но запомните этот пример и вернитесь к нему, когда дойдете до Принципов ООП в следующем курсе. А мы вернемся к ссылкам.

О том, что такое ссылка внутри и как оно работает - расскажем ниже, сейчас же давайте вернемся к решению нашей проблемы с функциями. К коду:

void fun(int& count)
{
    ++count;
    return;
} 

void main()
{
    int First = 0;
    fun(First);
    cout << First << endl;
    return;
}

Мы решили вернуться к самому первому примеру, который приводили в постановке проблемы. Кажется особенно забавным, что все решение заключалось в одном единственном символе &, поставленном у параметра функции. 

Да, теперь нам выведет столь желанное 1, так как в функцию мы передали именно адрес в нашей оперативной памяти, значение которого нужно менять. Кстати, теперь, мы думаем, вам стало понятно, почему большинство функций у программистов - void. Они просто принимают свои параметры по ссылкам и возвращать уже ничего не требуется - все и так будет в нужном виде. И вот наша проблема решена - элегантно и эффективно! Красота!

Но есть парочка тонких моментов, о которых прямо сейчас и поведаем.

Часть 3 - Как не сломать программу или Тонкости работы с ссылками?

Во-первых - ссылка может быть только того типа данных, что и переменная, на которую она ссылается! Сделано это таким образом для того, что бы некоторые, особо ушлые, программисты не пытались сломать программу своими махинациями. Для подтверждения достаточно ввести следующие строки:

{
    double First;
    int &Second = First;
}

И вы получите ошибку - "Невозможно присвоить сущность double в сущность int&".

С ссылками мы можем делать все тоже самое, что и с обычными переменными и именно поэтому было введено правило об одинаковости типов. Оно, кстати, касается и const переменных - Ссылаться на const переменную может только const ссылка! Работает ровно то же правило - если бы его не было, можно было натворить делов, а именно изменять значение того, что должно быть неизменным.

Во-вторых - ссылка, как и говорилось ранее, неизменяема! То есть вы не можете поменять переменную, на которую указывает ссылка. У этого тоже есть объяснение, но о нем позже, когда дойдем до указателей. А здесь нужно упомянуть следующее - переменная ссылки, если она не является параметром функции, ОБЯЗАНА быть проинициализирована сразу, при создании! Перефразировать это правило можно так - не может существовать ссылки, которая ни на что не указывает, если она не параметр функции. Это так же связанно определенным образом с указателями, а потому расскажем подробнее ниже.

Что же касается ссылок, как параметров функций - то они не могут иметь значения по-умолчанию. Тут все так же просто - какой адрес по-умолчанию вы поставите в ссылку? Верно, неизвестно. Единственное, что вы можете сделать с ссылкой в параметрах - это объявить ее const для того, что-бы дать понять программисту, который будет использовать вашу функцию, что этот параметр необходим вам только в качестве значения и не будет изменен. Кроме того, передавать const значения (например просто число в функцию fun из нашего примера выше) можно только, если ссылка объявлена const.

void fun(const int& count)
{
    ++count; // ошибка, потому что count - это const ссылка
    return;
} 

void main()
{
    int First = 0;
    fun(5);
    cout << First << endl;
    return;
}

Вот теперь вы знаете достаточно о ссылках, что бы их применять! Осталось только отметить, что для экономии памяти, желательно во всех функциях использовать ссылочные параметры, а возвращать из функции значение только, если параметры не должны изменяться - например, если функция складывает два числа, то их сумма она должна вернуть, не меняя сами числа. Многие это даже в правило возводят!


